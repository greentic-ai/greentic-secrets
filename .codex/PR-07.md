PR-07.md — IaC for CI “real cloud” provider tests (AWS/Azure/GCP) using GitHub OIDC/WIF
Title

greentic-secrets: add Terraform IaC to provision CI identities + least-privilege access for AWS SM, Azure KV, GCP Secret Manager integration tests

Goal

Provision (and document) the cloud-side resources needed for nightly/manual “real cloud” integration tests of:

AWS Secrets Manager provider

Azure Key Vault provider

GCP Secret Manager provider

No static credentials. Use:

AWS: GitHub OIDC → AssumeRole

Azure: Entra federated credential → azure/login

GCP: Workload Identity Federation → google-github-actions/auth

Non-goals

Provisioning production vaults / secrets.

Managing application secrets in GitHub.

Supporting every region/subscription/project style—start with a sane default and allow overrides.

Repo layout

Create:

infra/ci/
  README.md
  terraform/
    aws/
      main.tf
      variables.tf
      outputs.tf
      versions.tf
      iam_policy.json.tftpl
    azure/
      main.tf
      variables.tf
      outputs.tf
      versions.tf
    gcp/
      main.tf
      variables.tf
      outputs.tf
      versions.tf
  scripts/
    bootstrap.sh
    print_github_vars.sh


The intent: each cloud is independently deployable. Users can apply only what they need.

IaC requirements (all clouds)

Strict scoping

Permissions limited to a test-only namespace/prefix like:

ci/greentic-secrets/<repo>/<run_id>/...

If provider requires secret-name sanitization, apply it consistently.

Environment binding

Bind identity to:

GitHub owner/repo

branch or environment (e.g., main only)

workflow name optionally

Least privilege

Only required API permissions for create/put/get/delete (+ optional list for cleanup).

Outputs for GitHub configuration

Print the values you must store in GitHub Actions variables/secrets:

AWS role ARN, region

Azure client id / tenant id / subscription id / vault name

GCP workload identity provider id + service account email + project id

Part A — AWS (Secrets Manager) Terraform
Files

infra/ci/terraform/aws/versions.tf

Pin Terraform and AWS provider versions.

infra/ci/terraform/aws/variables.tf

aws_region

github_owner

github_repo

github_ref_pattern (default refs/heads/main)

role_name (default greentic-secrets-ci)

secrets_prefix (default ci/greentic-secrets)

tags map

infra/ci/terraform/aws/main.tf

Create:

aws_iam_openid_connect_provider for token.actions.githubusercontent.com

Use correct client_id_list and thumbprint_list (document how to get thumbprint; include a safe default; allow override)

aws_iam_role with trust policy:

Principal: OIDC provider

Condition:

sub matches repo:<owner>/<repo>:ref:<ref_pattern> (or environment binding if you use environments)

aud equals sts.amazonaws.com

aws_iam_policy for Secrets Manager actions restricted to prefix

Allow:

secretsmanager:CreateSecret

secretsmanager:PutSecretValue

secretsmanager:GetSecretValue

secretsmanager:DeleteSecret

Optional: secretsmanager:DescribeSecret, secretsmanager:ListSecrets (only if your cleanup uses list)

Restrict resources:

Secrets Manager ARNs are tricky because the random suffix is appended; use:

Resource: arn:aws:secretsmanager:<region>:<account>:secret:<prefix>*

Where <prefix> includes sanitized repo scope, e.g. ci/greentic-secrets/<owner>/<repo>/

Add a condition on secretsmanager:ResourceTag/greentic-ci = "true" if you tag secrets on creation (recommended).

Attach policy to role

infra/ci/terraform/aws/outputs.tf

role_arn

aws_region

account_id

Provider-side requirement (AWS tagging)

Update AWS provider integration test helper (if not already):

When creating a secret, attach tags:

greentic-ci=true

greentic-repo=<owner/repo>

greentic-run=<run_id>
This enables stricter IAM conditions later.

Acceptance criteria (AWS)

Applying Terraform yields a role ARN.

GitHub Actions can assume role and create/read/delete secrets only under the intended prefix.

Part B — Azure (Key Vault) Terraform
Files

infra/ci/terraform/azure/versions.tf

Pin azurerm and azuread providers.

infra/ci/terraform/azure/variables.tf

tenant_id

subscription_id

resource_group_name (create or reuse)

location

github_owner

github_repo

key_vault_name

use_rbac (default true)

Optional: github_environment (default empty)

tags

infra/ci/terraform/azure/main.tf
Create:

Azure AD application + service principal

azuread_application

azuread_service_principal

Federated identity credential

Use azuread_application_federated_identity_credential to trust GitHub OIDC

Subject options:

If using GitHub Environments (recommended):

repo:<owner>/<repo>:environment:<env>

Else bind to branch:

repo:<owner>/<repo>:ref:refs/heads/main

Audience: api://AzureADTokenExchange

Issuer: GitHub OIDC issuer

Key Vault

azurerm_key_vault

Enable purge protection/soft delete per your policies (for CI you may prefer soft delete on, purge protection off—document tradeoffs)

Permissions

Prefer RBAC:

Assign Key Vault Secrets Officer (too broad) is easy but not least-priv.

Better: use a custom role definition with:

Microsoft.KeyVault/vaults/secrets/read

.../write

.../delete

.../recover if soft delete is enabled

If custom roles are too heavy, start with Key Vault Secrets Officer but document the next hardening step.

Scope to that Key Vault only.

infra/ci/terraform/azure/outputs.tf

azure_client_id

azure_tenant_id

azure_subscription_id

azure_keyvault_name

Provider-side requirement (name sanitization)

Ensure the Azure test harness uses valid KV secret names:

lowercase

- instead of /

max length constraints

Acceptance criteria (Azure)

Terraform output includes client id, tenant id, subscription id, vault name.

azure/login using federated credential works in Actions and can set/get/delete secrets in that vault.

Part C — GCP (Secret Manager) Terraform
Files

infra/ci/terraform/gcp/versions.tf

Pin google provider.

infra/ci/terraform/gcp/variables.tf

project_id

region (optional)

github_owner

github_repo

pool_id (default gh-pool)

provider_id (default gh-provider)

service_account_id (default greentic-secrets-ci)

github_ref_pattern default refs/heads/main

tags/labels

infra/ci/terraform/gcp/main.tf
Create:

Workload Identity Pool

Workload Identity Provider:

issuer: GitHub OIDC

attribute mapping (at minimum):

attribute.repository from assertion repository

attribute.ref from assertion ref

attribute condition:

assertion.repository == "<owner>/<repo>" && assertion.ref == "refs/heads/main"

Service account

IAM bindings:

Allow principalSet from the provider to impersonate the service account:

roles/iam.workloadIdentityUser

Secret Manager permissions for the service account:

Prefer minimal:

roles/secretmanager.secretAccessor is not enough (needs create/delete)

Either:

Use predefined roles/secretmanager.admin scoped to project (simpler but broad)

OR create custom role with only:

secretmanager.secrets.create

secretmanager.secrets.delete

secretmanager.secrets.get

secretmanager.secrets.update (if needed)

secretmanager.versions.add

secretmanager.versions.access

Bind that role to the CI service account.

infra/ci/terraform/gcp/outputs.tf

gcp_project_id

gcp_service_account_email

gcp_workload_identity_provider (full resource name)

Acceptance criteria (GCP)

Terraform outputs provider resource name + SA email.

GitHub Actions auth works and can create/access/delete secrets in Secret Manager.

Part D — “One command” bootstrap + docs
infra/ci/README.md

Include:

What this infra is for

Cloud prerequisites

How to deploy each cloud

Which GitHub repo variables/secrets to set

How workflows pick them up

infra/ci/scripts/bootstrap.sh

A helper that:

validates terraform installed

runs terraform init/plan/apply for a selected cloud folder

prints outputs formatted as:

“Set these GitHub Variables”

“Set these GitHub Secrets” (if any, ideally none besides ids/names)

infra/ci/scripts/print_github_vars.sh

Prints exact names you expect the workflow to use:

AWS_ROLE_TO_ASSUME

AWS_REGION

AZURE_CLIENT_ID

AZURE_TENANT_ID

AZURE_SUBSCRIPTION_ID

AZURE_KEYVAULT_NAME

GCP_PROJECT_ID

GCP_SERVICE_ACCOUNT

GCP_WIF_PROVIDER

Prefer GitHub Repository Variables for non-sensitive values; use Secrets only when necessary.

Part E — Wire workflow to the IaC outputs

Update .github/workflows/secrets-providers.yml:

For aws_real, read:

role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}

aws-region: ${{ vars.AWS_REGION }}

For azure_real, read:

client-id: ${{ vars.AZURE_CLIENT_ID }}

tenant-id: ${{ vars.AZURE_TENANT_ID }}

subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

AZURE_KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME }}

For gcp_real, read:

workload_identity_provider: ${{ vars.GCP_WIF_PROVIDER }}

service_account: ${{ vars.GCP_SERVICE_ACCOUNT }}

GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}

Add a guard so jobs fail with a clear message if vars are missing.

Security hardening checklist (must implement in this PR)

Restrict AWS assume role to:

repo + ref (or environment)

Restrict Azure federated credential:

repo + ref/environment

Restrict GCP provider:

repo + ref condition

Ensure test secrets are:

namespaced by prefix

cleaned up (and optional scheduled janitor later)

Never log secret values

Tests for this PR (yes, test the infra)

Add “policy unit tests” in infra/ci/terraform/* using:

terraform validate

terraform fmt -check

Optional: tflint if you already use it (don’t introduce if you don’t)

Add a GitHub Actions job infra_validate:

runs on PR

checks formatting + validate for all three terraform modules

Acceptance criteria

infra_validate passes on PRs

Applying each terraform module produces outputs documented in infra/ci/README.md

Nightly/manual provider jobs can run against real clouds when the repo vars are set

No long-lived cloud secrets required anywhere

Codex execution notes (important)

Codex must implement PR-07 end-to-end without asking for permission:

create all files

include docs + scripts

update workflow to use vars

add infra validation job

If any provider version pins are missing, Codex chooses conservative stable versions and documents them in versions.tf.

If any cloud-specific values (like Azure location) need defaults, choose sane defaults and make them overridable via variables.
